# Tutorial

## 1. CST method

The class shape function transformation (CST) method combines class functions and shape functions to describe an arbitrary geometry and can guarantee airfoil smoothness with comparatively fewer design variables. Usually, a sixth-order Bernstein polynomial is used as the shape function; i.e., seven CST parameters are used to describe upper and lower surfaces.

Reference: Kulfan, B. M., “Universal parametric geometry representation method,” Journal of Aircraft, vol. 45, No. 1, 2008, pp. 142-158. (doi: 10.2514/1.29958)



<div align=center>
	<img src="airfoil\shape-function.png" width="400"> <br>
    Fig. CST shape functions (sixth-order)
</div>


```python
from cst_modeling.foil import cst_curve
from matplotlib import pyplot as plt

n_cst = 7
plt.figure()

for i in range(n_cst):
    cst = np.zeros(n_cst)
    cst[i] = 1.0
    x, y = cst_curve(101, cst)
    plt.plot(x, y)

plt.show()
```

The airfoil upper and lower surfaces are the **linear combinations** of these shape functions.



## 2. Airfoil

### 2.1 clean airfoils

Build a clean airfoil with given CST coefficients.

```python
import numpy as np
from cst_modeling.foil import cst_foil

cst_u = np.array([ 0.1185,  0.1189,  0.1557,  0.1367,  0.2092,  0.1483,  0.1935])
cst_l = np.array([-0.1155, -0.1341, -0.1091, -0.2532, -0.0122, -0.1184,  0.0641])
x, yu, yl, t0, R0 = cst_foil(1001, cst_u, cst_l, x=None, t=None, tail=0.0)

plt.figure()
plt.plot(x, yu, 'b')
plt.plot(x, yl, 'b')
plt.show()
```

<div align=center>
	<img src="airfoil\airfoil.png" width="300"> <br>
    Fig. A clean airfoil
</div>

Settings of this function:

```text
nn:     total amount of points on the upper/lower surfaces
x:      ndarray [nn]. If given, the points on the airfoil are placed by the given x.
t:      float. If given, the airfoil is scaled to have the given relative maximum thickness
tail:   float. If given, the airfoil is stretched to have the given relative tail thickness
        Meanwhile, the relative maximum thickness is kept unchanged if t is specified.
        Otherwise, the thickness will increase, when the tail is added.
```

<div align=center>
	<img src="airfoil\airfoil-tail-1.png" width="280"> <img src="airfoil\airfoil-tail-2.png" width="280"> <br>
    Fig. Adding tail to an airfoil (left: t=None, right: t=0.11)
</div>




### 2.2 CST coefficients of certain airfoil

Find the CST coefficients of a given airfoil by least square method.

This function allows the airfoil has non-zero tail thickness.

Also allows the airfoil chord length not equals to one.

```pytho
from cst_modeling.foil import cst_foil_fit
cst_u, cst_l = cst_foil_fit(x, yu, x, yl, n_order=n_cst)
# The cst_u, cst_l are ndarrays [n_cst]
```



### 2.3 output airfoils

Output the curves of airfoil upper and lower surfaces in Tecplot format.

```python
from cst_modeling.foil import output_foil
output_foil(x, yu, yl, fname='airfoil.dat', ID=0, info=False)
```

Settings of this function:

```text
fname:  otuput file name
ID:     ID of this airfoil, also the zone name
        When ID = 0, outputs the file header
info:   if True, then outputs the curvature, thickness and camber distribution
```



### 2.4 airfoil modification

Add bump function to the airfoil.

```python
from cst_modeling.foil import foil_bump_modify
xc = 0.7
h  = 0.02
s  = 0.6
yu_, yl_ = foil_bump_modify(x, yu, yl, xc, h, s, side=1)
```

Settings of this function:

```text
xc:         x location of the bump center
h:          bump height (can be either positive or negetive)
s:          bump width
side:       1/-1, modification to the upper/lower surface
n_order:    if specified (>0), then use CST to fit the new foil
```

<div align=center>
	<img src="airfoil\airfoil-bump.png" width="400"> <br>
    Fig. Bump modification to airfoil upper surface
</div>




### 2.5 airfoil increment

Add an incremental CST curve to the airfoil.

```python
from cst_modeling.foil import foil_increment
cst_u_ = np.zeros(16)
cst_l_ = np.zeros(16)
cst_u_[12] = 0.05
yu_, yl_ = foil_increment(x, yu, yl, cst_u_, cst_l_, t=t0)
```

Settings of this function:

```text
cst_u_:     CST coefficients of the incremental curve on the upper surface
cst_l_:     CST coefficients of the incremental curve on the lower surface
t:          optional float. If given, the airfoil relative maximum thickness is kept unchanged
```

<div align=center>
	<img src="airfoil\airfoil-increment.png" width="400"> <br>
    Fig. Increment to airfoil upper surface
</div>


The green dash curve is the incremental CST curve.



## 3. Wing

The wing surface is a multi-section surface, which is defined by an object of **Surface** class. The **Surface** class contains several **Section** objects that define the control sections of the surface.

### 3.1 relevant class

#### Section

A class for control sections. The section 2D curves, i.e., the upper and lower surfaces, are generated by CST method. The 3D curve is transformed from the 2D curve, which starts from the lower surface trailing edge and ends at the upper surface trailing edge. The 3D curve is still a plane curve, the leading edge location, chord length, twist angle (deg), maximum relative thickness, relative tail thickness are defined by user. 

```python
from cst_modeling.foil import Section
sec = Section(thick=None, chord=1.0, twist=0.0, tail=0.0)
```

Parameters of this class:

```text
cst_u, cst_l:   ndarray, CST parameters
xLE, yLE, zLE:  leading edge coordinates (3D curve is in XY plane)
chord:          chord length of the section
twist:          twist angle (degree) of the chord line 
                (positive is defined by +Z direction with right hand rule)
tail:           relative tail thickness
thick:          relative maximum thickness (default None, means thickness not specified)

refine_u,refine_l:  ndarray, cst coefficients of upper and lower incremental curves
refine_fixed_t:     bool, whether fix thickness when adding incremental curves

flip_x:         if True, arrange xx and x in the reverse order
```

Attributes of this class: 

```text
RLE:        leading edge radius
xx, yu, yl: ndarray, coordinates of 2D upper and lower curve (uniform chord length)
x, y, z:    ndarray, coordinated of the 3D curve
```



#### Surface

A class for multi-section surfaces. The **Surface** class contains several **Section** objects that define the control sections of the surface.

```python
from cst_modeling.surface import Surface
wing = Surface(n_sec=3, name='Wing')
wing.read_setting('Wing.txt', tail=[0.1, 0.1, 0.1])
```

Orientation:

```text
+x:     flow direction (m)
+y:     upside (m)
+z:     spanwise (m)
twist:  +z direction (deg)
```

Parameters of this class:

```text
n_sec:      number of control sections (if 2D, set to 0 or 1)
tail:       float or list, absolute tail thickness (m)
name:       name of the surface
nn:         number of points on upper or lower section surface
ns:         number of spanwise points

project:    if True, projected chord length does not change when being twisted
split:      if True, surface between two sections is splitted into upper and lower surfaces
flip_x:     if True, arrange xx and x of control sections in the reverse order
```

Attributes of this class: 

```text
l2d:        bool, whether is 2D surface

secs:       list of Section objects (length is n_sec)
surfs:      list of [surf_x, surf_y, surf_z], surf_ is [ns, nn] ndarray

zLE_secs:   list of z cooridnates of section leading edges
half_s:     float, half span
center:     ndarray, center coordinates for better plot with matplotlib
```



### 3.2 simple wing

Build a simple wing 

```python
from cst_modeling.surface import Surface 
wing = Surface(n_sec=3, name='Wing-basic', nn=101, ns=21)
wing.read_setting('Wing.txt')
wing.geo()
wing.output_tecplot(fname='Wing-basic.dat')
```

The control file of the wing configuration and wing section geometry is 'Wing.txt'. The relevant settings are listed under the name of 'Wing-basic'.

```text
 ==========================================
 [Surf] Wing-basic
 ==========================================
 ---------------------------------------------------
 Layout: LE XYZ(m),  chord(m), twist(deg), rel-thick
 ---------------------------------------------------
    0.0  0.0   0.0     5.5        3.0        0.18
    2.0  1.0   7.0     3.2        0.0        0.14
    6.0  3.0  21.0     1.0       -3.0        0.10
 ---------------------------------------------------
 CST_coefs:
 ---------------------------------------------------
 Section 1---------------
    1.0   1.0   1.0   1.0   1.0   1.0   1.0
   -1.0  -1.0  -1.0  -1.0  -1.0  -1.0  -1.0
 Section 2---------------
    1.0   1.0   1.0   1.0   1.0   1.0   1.0
   -1.0  -1.0  -1.0  -1.0  -1.0  -1.0
 Section 3---------------
    1.0   1.0   1.0   1.0   1.0
   -1.0  -1.0  -1.0  -1.0  -1.0
```

Note:

* **[Surf]** is the flag for class **Surface** to locate the settings. It is followed by the name of the **Surface** object. There can be multiple **[Surf]** flags in one control file, e.g., 'Wing.txt'. Only the **[Surf]** followed by the same name (must be one string) is read.
* **Layout** is the flag that defines the configuration. The leading edge coordinates, chord length, twist angle, and maximum relative thickness of each control section are listed under **Layout**. Each line defines one control section.
* **CST_coefs** is the flag that defines the CST parameters of each control section. Each control section is defined with two lines that contains the CST parameters of the upper surface and lower surface, respectively. The number of CST parameters can be different in any line.
* **CST_refine** is the flag that defines the CST parameters of incremental curves for each control section. This part is optional, if not provided or *n_cst* is 0, this function is disabled. Otherwise, the upper and lower surface of each control section are added with an incremental curve defined with the following CST parameters. The incremental curves are implemented with **foil_increment** function in section 2.5. The *n_cst* is the number of CST parameters of the incremental curve, the *start-index* (starting from 0) is the index of the first CST parameter that is not zero. In other words, the following settings of the upper surface of the first control section means that the incremental curve is defined by 20 CST parameters. All the parameters are zero except for the two parameters *'0.1  0.1'* that starts from index 0, which means the CST parameters are [0.1, 0.1, 0.0, ...., 0.0].

```text
 ---------------------------------------------------
 CST_refine:
 ---------------------------------------------------
 n_cst   start-index
  20        0
 Section 1---------------
    0.1   0.1   
   -0.1  -0.1
 Section 2---------------
    0.1   0.1   0.1
    0.0   0.0
 Section 3---------------
    0.0   0.0
    0.0   0.0
```



The Wing-basic.dat can be opened with *Tecplot*.

<div align=center>
	<img src="wing\wing-basic.jpg" width="500"> <br>
    Fig. A simple wing surface and its control sections <br>
    <img src="wing\wing-basic-ZX.jpg" width="280">
    <img src="wing\wing-basic-XY.jpg" width="280"> <br>
    Fig. Top view and side view
</div>



### 3.3 functions

Detailed settings can be found in the comments of each function.

#### geo_secs

Generate the surface sections.

```python
wing.geo_secs(flip_x=False)
```

```text
flip_x:     if True, flip section.xx in reverse order
```



#### geo

Generate the surface geometry.

```python
wing.geo(flip_x=False, update_sec=True)
```

```text
flip_x:     if True, flip section.xx in reverse order
update_sec: if True, update control sections
```



#### add_sec

Add sections to the surface, the new sections are interpolated from current ones.

Must run before geo(), geo_secs() and flip(). This automatically updates the curves of all sections.

```python
wing.add_sec(location: list, axis='Z')
```

```text
location:   list of spanwise location (must within the range of current sections)
axis:       string 'Y' or 'Z', the direction for interplotation

```

#### flip

Rotate 90 degrees about the given axis, or get symmetry of given plane.

This should be the last action.

```python
wing.flip(axis='None', plane='None')
```

```text
axis:    turn 90 degrees about axis: +X, -X, +Y, -Y, +Z, -Z
plane:   get symmetry about plane: 'XY', 'YZ', 'ZX'
```

The *axis* and *plane* can be a single string, or a string contains multiple actions to take in order, e.g., '+X  +Y'.



#### bend

Bend surfaces by a guide curve. The guide curve is defined by *leader*, i.e., a list of points defining a spline curve. Then, regenerate the surfaces between section *isec0* and *isec1*.

```python
wing.bend(isec0: int, isec1: int, leader=None, kx=None, ky=None, rot_x=False)
```

```text
isec0:  the index of starting section
isec1:  the index of ending section
leader: list of points (and chord length) in the guide curve. [[x,y,z(,c)], [x,y,z(,c)]]
axis:   Z-axis, spanwise direction
kx:     X-axis slope (dx/dz) at both ends [kx0, kx1]
ky:     Y-axis slope (dy/dz) at both ends [ky0, ky1]
rot_x:  if True, rotate sections about x-axis to make the section vertical to the leader
```

<div align=center>
	<img src="wing\bend-wing.jpg" width="500"> <br>
    Fig. Bent wing (green) and linear interpolation wing (gray)
</div>



#### smooth

Smooth the spanwise curve between *isec0* and *isec1*.

```python
wing.smooth(isec0: int, isec1: int)
```

<div align=center>
	<img src="wing\wing-tip.jpg" width="500"> <br>
    Fig. Smooth wing surface and wing tip
</div>
Relevant code:

```python
from cst_modeling.surface import Surface
wing = Surface(n_sec=6, name='Wing-tip', nn=101, ns=101)
wing.read_setting('Wing.txt', tail=[0.1, 0.1, 0.1, 0.1, 0.05, 0.01])
wing.geo()
wing.bend(4, 5, leader=[[21.0, 2.1, 30.0, 1.6]], kx=[0.6983, 4.0], ky=[0.1043, 1.10], rot_x=True)
wing.smooth(0,2)
wing.smooth(2,4)
wing.output_tecplot(fname='Wing-tip.dat')
```



#### output_tecplot

Output the surface to *.dat in *Tecplot* format.

```python
wing.output_tecplot(fname=None, one_piece=False, split=False)
```

```text
fname:      string (the name of the file), or None (default name)
one_piece:  if True, combine the spanwise sections into one piece
split:      if True, split to upper and lower surfaces
```



#### output_plot3d

Output the surface to *.grd in *plot3d* format.

```python
wing.output_plot3d(fname=None)
```



## 4. Fan blade

The blade surface is a multi-section surface, which is defined by an object of **Surface** class or **OpenSurface**. The **Surface** class contains several **Section** objects that define the control sections of the surface. The **OpenSurface** class contains several **OpenSection** objects.

### 4.1 simple blade

Build a simple blade.

```python
from cst_modeling.surface import Surface
blade = Surface(n_sec=6, name='Blade-simple',nn=101, ns=51, project=False)
blade.read_setting('Fan.txt', tail=[0.1, 0.1, 0.1, 0.1, 0.1, 0.05])
blade.geo()
blade.smooth(isec0=0, isec1=4)
blade.smooth(isec0=4, isec1=5, smooth0=True)
blade.Surf2Cylinder(flip=True)
blade.output_tecplot(fname='Blade-simple.dat')
```

The control file of the wing configuration and wing section geometry is 'Fan.txt'. The relevant settings are listed under the name of 'Blade-simple'.

<div align=center>
    <img src="blade\blade-simple-1.jpg" width="280">
    <img src="blade\blade-simple-2.jpg" width="280"> <br>
    Fig. Simple blade
</div>

Each section is on a cylinder surface of which the axis is Z-axis. 



### 4.2 relevant class

#### OpenSection

A class for control sections. The section 2D curve is generated by CST method. The 3D curve is transformed from the 2D curve. The 3D curve is still a plane curve, the leading edge location, chord length, twist angle (deg), maximum relative thickness are defined by user. 

```python
from cst_modeling.foil import OpenSection
sec = OpenSection(thick=None, chord=1.0, twist=0.0)
```

Parameters of this class:

```text
cst:            ndarray, CST parameters
xLE, yLE, zLE:  leading edge coordinates (3D curve is in XY plane)
chord:          chord length of the section
twist:          twist angle (degree) of the chord line 
                (positive is defined by +Z direction with right hand rule)
thick:          relative maximum thickness (default None, means thickness not specified)
refine:         ndarray, cst coefficients of the incremental curve
flip_x:         if True, arrange xx and x in the reverse order
```

Attributes of this class: 

```text
xx, yy:     ndarray, coordinates of 2D curve (uniform chord length)
x, y, z:    ndarray, coordinated of the 3D curve
```



#### OpenSurface

A class for multi-section surfaces. The **OpenSurface** class contains several **OpenSection** objects that define the control sections of the surface.

Orientation:

```text
+x:     flow direction (m)
+y:     upside (m)
+z:     spanwise (m)
twist:  +z direction (deg)
```

Parameters of this class:

```text
n_sec:      number of control sections (if 2D, set to 0 or 1)
name:       name of the surface
nn:         number of points on upper or lower section surface
ns:         number of spanwise points

project:    if True, projected chord length does not change when being twisted
flip_x:     if True, arrange xx and x of control sections in the reverse order
```

Attributes of this class: 

```text
l2d:        bool, whether is 2D surface

secs:       list of Section objects (length is n_sec)
surfs:      list of [surf_x, surf_y, surf_z], surf_ is [ns, nn] ndarray

zLE_secs:   list of z cooridnates of section leading edges
half_s:     float, half span
center:     ndarray, center coordinates for better plot with matplotlib
```



### 4.3 extract parameters from raw data

For most cases, a baseline blade geometry is provided in *CATIA* format or other formats. The layout parameters and CST parameters need to be extracted from the baseline raw data.

First, extract the curve geometry of each control section from the provided geometry. The curve geometries are stored in a *Tecplot* format file. Each zone is the geometry of the upper or lower surface of the control section. There is a blank line following each zone. See *ori-sections.dat*.

```text
Variables= X  Y  Z 
zone i= 101
15.180000  13.292000  15.057000
15.359016  13.088470  15.071225
......
20.936083  -3.706492  -3.187288
20.926029  -3.836604  -3.425423

zone i= 101
20.996319  -2.382432  -3.425094
20.998522  -2.212356  -3.234451
......
```

Then, extract the cylinder axis origin, the layout parameters, and the CST parameters. See *test-fromCylinder.py*.

```python
from cst_modeling.foil import fit_curve_with_twist, fromCylinder, find_circle_3p

with open('ori-sections.dat', 'r') as f:

    for i in range(12):

        #* Read coordinates of the original curve on cylinder
        #  x, y, z

        #* Locate origin of cylinder axis
        #  It is better to use cylinders of which the axis is Z-axis to extract the curves 
        ii = int(0.5*n_point)
        _, origin = find_circle_3p([x[0], y[0]], [x[ii], y[ii]], [x[-1], y[-1]])

        #* Convert to plane curve
        #  The layout parameters are defined for plane curves
        #  Therefore, must convert to plane curves, then convert back to cylinder
        xx, yy, zz = fromCylinder(x, y, z, flip=True, origin=origin)

        #* Coordinates of the leading edge
        #  xx[0], yy[0], zz[0]

        #* CST coefficients, chord length, twist, and relative thickness
        cst, chord, twist, thick = fit_curve_with_twist(xx, yy, n_order=7)
```



### 4.4 blade with suction side and pressure side

In many cases, the chord lengths of the suction and pressure side are different, and the cylinder axes are not always Z-axis. The suction side and the pressure side need to be constructed separately.  Then, use **OpenSurface** to construct the suction and pressure surfaces. The relevant settings are listed below. See *test-blade-split.py*.

```text
 ==========================================
 [Surf] Blade-suction
 ==========================================
 ---------------------------------------------------
 Layout: LE XYZ, chord length, twist(deg), rel-thick
 ---------------------------------------------------
   -16.727744  15.057000  23.000111  26.197782  -44.869607  0.111400 
   -20.505167  14.767008  27.266841  25.952369  -40.803223  0.113682 
   -25.834969  16.452906  30.249798  27.959412  -39.148119  0.098001 
 ---------------------------------------------------
 CST_coefs:
 ---------------------------------------------------
 Section 1 ---------------
   0.111283   0.371933   0.153438   0.452797   0.225870   0.364799   0.275790 
 Section 2 ---------------
   0.208236   0.325437   0.246680   0.364159   0.275120   0.318604   0.277516 
 Section 3 ---------------
   0.176286   0.295879   0.195508   0.331298   0.217786   0.277981   0.231467
 ---------------------------------------------------
 CylinderOrigin:
 ---------------------------------------------------
  -2.000602   -1.999567 
  -1.830067   -1.363773 
  -1.649559   -1.547927 
```



## 5. Nacelle

The nacelle surface is a multi-section surface, which is defined by an object of **Surface** class or **OpenSurface**. The **Surface** class contains several **Section** objects that define the control sections of the surface. The **OpenSurface** class contains several **OpenSection** objects.

### 5.1 simple nacelle

```python
nacelle = Surface(n_sec=5, name='Nacelle-simple', nn=201, ns=101)
nacelle.read_setting('Nacelle.txt', tail=0.1)
phi = [0.0, 90.0, 180.0, 270.0, 360.0]
nacelle.geo_axisymmetric(phi)
nacelle.smooth_axisymmetric(0, 4, phi, linear_TE=True)
nacelle.output_tecplot(fname='Nacelle-simple.dat')
```

The control file of the nacelle configuration and nacelle section geometry is 'Nacelle.txt'. The relevant settings are listed under the name of 'Nacelle-simple'.

<div align=center>
    <img src="nacelle\nacelle-simple.jpg" width="280">
    <img src="nacelle\nacelle-sideview.jpg" width="280"> <br>
    Fig. Simple nacelle (left: 3D view; right: side view)
</div>

The black solid curves are the control sections. The nacelle has smooth surfaces.

In order to have a closed surface, there are five control sections in the configuration definition, even though only four control sections are effective. In other words, the first and last control section must be the same, so that the surface can be closed. The *phi* is a list of position angle of control sections, the length of *phi* must be *n_sec*.

### 5.2 real nacelle

Real nacelles have asymmetry geometries. However, the outlet is usually a circle.

```python
def func_trans(tx, x_cri=0.6):
    if tx < x_cri:
        ratio = 0.0
    else:
        ratio = ((tx-x_cri)/(1-x_cri))**20
    return ratio

nacelle = Surface(n_sec=7, name='Nacelle', nn=51, ns=51)
nacelle.read_setting('Nacelle.txt', tail=0.02)
phi = [0.0, 90.0, 135.0, 180.0, 225.0, 270.0, 360.0]
nacelle.geo_axisymmetric(phi)
nacelle.smooth_axisymmetric(0, 6, phi, linear_TEx=True, RTE=0.8, RTE_=0.78, func_trans=func_trans)
nacelle.output_tecplot(fname='Nacelle.dat', one_piece=False, split=False)
```

<div align=center>
    <img src="nacelle\nacelle.jpg" width="280">
    <img src="nacelle\nacelle-frontview.jpg" width="280"> <br>
    Fig. Real nacelle (left: 3D view; right: front view)
</div>

