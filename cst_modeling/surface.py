'''
This is a module containing functions to construct a surface.
The surface is interploted by sections, e.g., airfoils
'''
import os
import copy
import numpy as np

import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

from cst_modeling.foil import Section
from cst_modeling.foil import cst_foil, transform, output_foil

class Surface:
    '''
    Surface class, CST surface generated by sections
    '''

    def __init__(self, n_sec=None, n_cst=None, tail=0.0, name='Wing' ,fname=None, nn=1001, ns=101):
        '''
        Initialize the CST surface (upper & lower)
            n_sec:  number of control sections
            n_cst:  number of CST parameters
            tail:   tail thickness (m)
            name:   name of the surface
            fname:  name of control file (not None: read in settings)
            nn:     number of points of upper/lower section
            ns:     number of spanwise points

        Data:
            secs:   list of [Section] class
            surfs:  list of [surf_x, surf_y, surf_z], they are [nn, ns] lists
        '''
        self.n_sec = max(1, n_sec)
        self.l2d   = self.n_sec == 1
        self.name  = name
        self.n_cst = n_cst
        self.nn    = nn
        self.ns    = ns
        self.secs  = [ Section() for _ in range(n_sec) ]
        self.surfs = []

        self.split = False

        # Parameters for plot
        self.half_s = 0.5
        self.center = [0.5, 0.5, 0.5]


        if not fname is None:
            self.read_setting(fname, tail=tail)

    def read_setting(self, fname, tail=0.0):
        '''
        Read in Surface layout and CST parameters from file [fname]
        '''
        if not os.path.exists(fname):
            raise Exception(fname+' does not exist for surface read setting')
        
        key_dict = {'Layout:': 1, 'CST_coefs:': 2}

        found_surf = False
        found_key = 0
        with open(fname, 'r') as f:

            for line in f:
                line = line.split()

                if len(line) < 1:
                    continue
                
                if not found_surf and len(line) > 1:
                    if '[Surf]' in line[0] and self.name in line[1]:
                        found_surf = True

                elif found_key == 0:
                    if line[0] in key_dict:
                        found_key = key_dict[line[0]]

                elif found_key == 1:
                    for i in range(self.n_sec):
                        line = f.readline().split()
                        self.secs[i].xLE   = float(line[0])
                        self.secs[i].yLE   = float(line[1])
                        self.secs[i].zLE   = float(line[2])
                        self.secs[i].chord = float(line[3])
                        self.secs[i].twist = float(line[4])
                        self.secs[i].thick = float(line[5])
                        self.secs[i].tail  = tail/self.secs[i].chord

                        if self.l2d:
                            self.secs[i].zLE = 0.0

                    found_key = 0

                elif found_key == 2:
                    for i in range(self.n_sec):
                        line = f.readline()
                        line = f.readline().split()
                        self.secs[i].cst_u = [float(line[i]) for i in range(self.n_cst)]
                        line = f.readline().split()
                        self.secs[i].cst_l = [float(line[i]) for i in range(self.n_cst)]
                    
                    found_key = 0

                else:
                    # Lines that are not relevant
                    pass
        
        print('Read surface [%s] settings'%(self.name))

        # Locate layout center for plot
        x_range = [self.secs[0].xLE, self.secs[0].xLE]
        y_range = [self.secs[0].yLE, self.secs[0].yLE]
        z_range = [self.secs[0].zLE, self.secs[0].zLE]
        for i in range(self.n_sec):
            x_range[0] = min(x_range[0], self.secs[i].xLE)
            x_range[1] = max(x_range[1], self.secs[i].xLE+self.secs[i].chord)
            y_range[0] = min(y_range[0], self.secs[i].yLE)
            y_range[1] = max(y_range[1], self.secs[i].yLE)
            z_range[0] = min(z_range[0], self.secs[i].zLE)
            z_range[1] = max(z_range[1], self.secs[i].zLE)
        
        span = np.array([x_range[1]-x_range[0], y_range[1]-y_range[0], z_range[1]-z_range[0]])
        self.half_s = span.max()/2.0
        self.center[0] = 0.5*(x_range[1]+x_range[0])
        self.center[1] = 0.5*(y_range[1]+y_range[0])
        self.center[2] = 0.5*(z_range[1]+z_range[0])

    def geo(self, showfoil=False, split=False):
        '''
        Generate surface geometry
            showfoil:   True ~ output name-foil.dat of airfoils
            split:      True ~ generate [surfs] as upper and lower separately
        '''
        for i in range(self.n_sec):
            self.secs[i].foil(nn=self.nn)
            if showfoil:
                output_foil(self.secs[i].xx, self.secs[i].yu, self.secs[i].yl, ID=i, info=True, fname=self.name+'-foil.dat')

        self.split = split
        self.surfs = []
        if not split:

            if self.l2d:
                surf_x, surf_y, surf_z = Surface.section(
                    self.secs[0].x, self.secs[0].y, [0.0 for i in range(self.nn*2-1)],
                    self.secs[0].x, self.secs[0].y, [1.0 for i in range(self.nn*2-1)],
                    ns = self.ns
                )
                self.surfs.append([surf_x, surf_y, surf_z])
                return

            for i in range(self.n_sec-1):
                surf_x, surf_y, surf_z = Surface.section(
                    self.secs[i].x, self.secs[i].y, self.secs[i].z,
                    self.secs[i+1].x, self.secs[i+1].y, self.secs[i+1].z,
                    ns = self.ns
                )
                self.surfs.append([surf_x, surf_y, surf_z])

        else:
            # Split into upper and lower surface
            nn = self.nn
            if self.l2d:
                surf_x, surf_y, surf_z = Surface.section(
                    self.secs[0].x[:nn][::-1], self.secs[0].y[:nn][::-1], [0.0 for i in range(self.nn)],
                    self.secs[0].x[:nn][::-1], self.secs[0].y[:nn][::-1], [1.0 for i in range(self.nn)],
                    ns = self.ns
                )
                self.surfs.append([surf_x, surf_y, surf_z])

                surf_x, surf_y, surf_z = Surface.section(
                    self.secs[0].x[nn-1:], self.secs[0].y[nn-1:], [0.0 for i in range(self.nn)],
                    self.secs[0].x[nn-1:], self.secs[0].y[nn-1:], [1.0 for i in range(self.nn)],
                    ns = self.ns
                )
                self.surfs.append([surf_x, surf_y, surf_z])
                return

            for i in range(self.n_sec-1):
                surf_x, surf_y, surf_z = Surface.section(
                    self.secs[i  ].x[:nn][::-1], self.secs[i  ].y[:nn][::-1], self.secs[i  ].z[:nn][::-1],
                    self.secs[i+1].x[:nn][::-1], self.secs[i+1].y[:nn][::-1], self.secs[i+1].z[:nn][::-1],
                    ns = self.ns
                )
                self.surfs.append([surf_x, surf_y, surf_z])

                surf_x, surf_y, surf_z = Surface.section(
                    self.secs[i  ].x[nn-1:], self.secs[i  ].y[nn-1:], self.secs[i  ].z[nn-1:],
                    self.secs[i+1].x[nn-1:], self.secs[i+1].y[nn-1:], self.secs[i+1].z[nn-1:],
                    ns = self.ns
                )
                self.surfs.append([surf_x, surf_y, surf_z])

    def plot(self, fig_id=1, type='wireframe'):
        '''
        Plot surface
            fig_id: ID of the figure
            type:   wireframe, surface
        '''
        fig = plt.figure(fig_id)
        ax = Axes3D(fig)

        n_plot = self.n_sec-1
        if self.l2d:
            n_plot += 1

        if self.split:
            n_plot = n_plot * 2

        for i in range(n_plot):
            X = np.array(self.surfs[i][0])
            Y = np.array(self.surfs[i][1])
            Z = np.array(self.surfs[i][2])

            if type in 'wireframe':
                ax.plot_wireframe(X, Y, Z)
            else:
                ax.plot_surface(X, Y, Z)

        ax.set_xlabel('X')
        ax.set_ylabel('Y')
        ax.set_zlabel('Z')
        ax.set_xlim3d(self.center[0]-self.half_s, self.center[0]+self.half_s)
        ax.set_ylim3d(self.center[1]-self.half_s, self.center[1]+self.half_s)
        ax.set_zlim3d(self.center[2]-self.half_s, self.center[2]+self.half_s)
        plt.show()

    def copyfrom(self, other):
        '''
        Copy from another Surface class
        '''
        if not isinstance(other, Surface):
            raise Exception('Can not copy from a non-surface object')

        self.n_sec = other.n_sec
        self.l2d   = other.l2d
        self.name  = other.name
        self.n_cst = other.n_cst
        self.nn    = other.nn
        self.ns    = other.ns
        self.secs  = copy.deepcopy(other.secs)
        self.surfs = copy.deepcopy(other.surfs)

        self.split = other.split

        self.half_s = other.half_s
        self.center = copy.deepcopy(other.center)

    def output_tecplot(self, fname=None, one_piece=False):
        '''
        Output the surface to *.dat in Tecplot format
            fname:      the name of the file
            one_piece:  True ~ combine the spanwise sections into one piece
        '''
        if fname is None:
            fname = self.name + '.dat'

        n_sec   = 1 if self.l2d else self.n_sec-1
        n_piece = 2*n_sec if self.split else n_sec
        
        with open(fname, 'w') as f:
            f.write('Variables= X  Y  Z \n ')

            if not one_piece:

                for isec in range(n_piece):
                    X = self.surfs[isec][0]
                    Y = self.surfs[isec][1]
                    Z = self.surfs[isec][2]

                    # X[nn][ns], ns => spanwise
                    nn = len(X)
                    ns = len(X[0])

                    if self.split and isec%2==0:
                        f.write('zone T="SecUpp  %d" i= %d j= %d \n'%(isec, nn, ns))
                    elif self.split and isec%2==1:
                        f.write('zone T="SecLow  %d" i= %d j= %d \n'%(isec, nn, ns))
                    else:
                        f.write('zone T="Section %d" i= %d j= %d \n'%(isec, nn, ns))

                    for i in range(ns):
                        for j in range(nn):
                            f.write('  %.9f   %.9f   %.9f\n'%(X[j][i], Y[j][i], Z[j][i]))
                            
            else:
                
                n_part = 2 if self.split else 1
                npoint = n_sec*(self.ns-1) + 1

                for ii in range(n_part):

                    nn = len(self.surfs[0][0])
                    if self.split and ii%2==0:
                        f.write('zone T="SecUpp"  i= %d j= %d \n'%(nn, npoint))
                    elif self.split and ii%2==1:
                        f.write('zone T="SecLow"  i= %d j= %d \n'%(nn, npoint))
                    else:
                        f.write('zone T="Section" i= %d j= %d \n'%(nn, npoint))

                    for isec in range(n_piece):
                        X = self.surfs[isec][0]
                        Y = self.surfs[isec][1]
                        Z = self.surfs[isec][2]

                        # X[nn][ns], ns => spanwise
                        nn = len(X)
                        ns = len(X[0])
                        i_add = 0 if isec>=n_piece-2 else 1

                        if self.split and isec%2!=ii:
                            continue
                        else:
                            for i in range(ns-i_add):
                                for j in range(nn):
                                    f.write('  %.9f   %.9f   %.9f\n'%(X[j][i], Y[j][i], Z[j][i]))

    def output_plot3d(self, fname=None):
        '''
        Output the surface to *.grd in plot3d format
            fname: the name of the file
        '''
        if fname is None:
            fname = self.name + '.grd'

        n_sec   = 1 if self.l2d else self.n_sec-1
        n_piece = 2*n_sec if self.split else n_sec

        # X[nn][ns], ns => spanwise
        X = self.surfs[0][0]
        nn = len(X)
        ns = len(X[0])
        
        with open(fname, 'w') as f:
            f.write('%d \n '%(n_piece))     # Number of surfaces
            for isec in range(n_piece):
                f.write('%d %d 1\n '%(nn, ns))

            for isec in range(n_piece):
                X = self.surfs[isec][0]
                ii = 0
                for i in range(ns):
                    for j in range(nn):
                        f.write(' %.9f '%(X[j][i]))
                        ii += 1
                        if ii%3 == 0:
                            f.write(' \n ')

                Y = self.surfs[isec][1]
                ii = 0
                for i in range(ns):
                    for j in range(nn):
                        f.write(' %.9f '%(Y[j][i]))
                        ii += 1
                        if ii%3 == 0:
                            f.write(' \n ')

                Z = self.surfs[isec][2]
                ii = 0
                for i in range(ns):
                    for j in range(nn):
                        f.write(' %.9f '%(Z[j][i]))
                        ii += 1
                        if ii%3 == 0:
                            f.write(' \n ')



                            
 

    @staticmethod
    def section(x1, y1, z1, x2, y2, z2, ns=101, kind='S'):
        '''
        Interplot surface section between curves
            x1, y1, z1:     curve lists [nn]
            x2, y2, z2:     curve lists [nn]
            ns:             number of spanwise points
            kind (S/L):     interplot method, linear or smooth

        Return: surf_x, surf_y, surf_z [nn, ns] (list)
        '''
        nn = len(x1)
        if nn!=len(y1) or nn!=len(x2) or nn!=len(y2):
            raise Exception('Interplot surface section, must have same length curves')

        ratio = []
        for i in range(ns):
            if kind in 'Linear':
                tt = 1.0*i/(ns-1.0)
            else:
                tt = 0.5*(1-np.cos(np.pi*i/(ns-1.0)))
            ratio.append(tt)

        surf_x = np.zeros((nn,ns))
        surf_y = np.zeros((nn,ns))
        surf_z = np.zeros((nn,ns))
        for j in range(nn):
            for i in range(ns):
                surf_x[j][i] = (1-ratio[i])*x1[j] + ratio[i]*x2[j]
                surf_y[j][i] = (1-ratio[i])*y1[j] + ratio[i]*y2[j]
                surf_z[j][i] = (1-ratio[i])*z1[j] + ratio[i]*z2[j]

        return surf_x.tolist(), surf_y.tolist(), surf_z.tolist()


